## 调试

- sizeof(vertecies) 返回的是vertecies的**类型**Vertex的字节数
- 索引缓冲的数据类型定义和使用要一致
- 缓冲的偏移最小值（256）
- anvil的image的base_mipmap，高要为偶数
- 图像、图像视图（及帧缓冲附件）、渲染流程附件，三者都需要设置图像格式！！！
- OpenGL、Vulkan、D3D、Metal裁剪坐标系和UV的区别
- Vulkan裁剪坐标的Y轴是倒的！！！刚好跟UV坐标方向相同！！原来是这样的良苦用心！！不用像D3D一样再翻转Y轴。模型的世界坐标通常在左下角，而纹理图像的坐标通常在左上角（可能是因为windows屏幕坐标在左上角），为了调和这样的矛盾，vulkan才让裁剪坐标的y轴朝下。
- vulkan/opengl 相机朝向z负轴，D3D朝向z正轴
- 等所有类实例化后再处理消息：设置条件断点
- 主循环封装在m_window_ptr中，不能对它重新初始化
- compute不能放进render pass里
- vulkan推常数是在记录指令时就写死的
- 数据对齐：vulkan uniform buffer使用的是“vector-relaxed”std140，storage buffer使用的是“vector-relaxed”std430。
  - 大小为N的标量的基本对齐方式为N。
  - 具有分量N的分量的二分量对齐为2N；三分量或四分量向量对齐为4N
  - 矩阵对齐数等于它的成员
  - std140更严格：内嵌数组和结构体对齐为【成员的最大对齐,16】的倍数
- glm强制对齐会把vec3填充成vec4！！！
- vulkan矩阵只能以列为主，一级索引就是列向量；D3D默认以行为主，一级索引是行向量，但可以初始化为以列为主。主要是shader与外部数据格式要统一，至于内部储存和使用的规则是一样的，所以是列还是行都无所谓。glm是以列为主储存的！
- 默认时，D3D顺时针为正面，而vulkan/opengl为反面，两者都默认剔除反面
- 一步一步输出颜色，本应该：00-0，01-0.33，10-0.66，11-1.0，但是格式A2无法写入值，是设备原因吗？只能从材质那里挪一位给它了。
- 深度图像，会有散列分布的点无法读取，猜测可能是同步问题？暂时放弃使用深度图像，自己单独存放
- 并行读写数据要用原子操作

## vulkan优化

+ 只申请一块内存
+ 只申请一块缓冲区
+ 把所有数据存到这个缓冲区中
+ 延迟纹理mipmap无效，因为在计算着色器中无法获取顶点到屏幕的距离，可以使用textureGrad采样
+ 绑定的uniform最多只能15个
+ 每条管线绑定的描述符集最多只能6个

Nsight好东西！可以看资源同步情况、管线状态、资源绑定情况

尽可能每次只实现小部分功能，不然bug难以定位

uniform vs storage